// Import Workbox libraries
import { precacheAndRoute } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { CacheFirst, NetworkFirst } from "workbox-strategies"
import { ExpirationPlugin } from "workbox-expiration"
import { CacheableResponsePlugin } from "workbox-cacheable-response"

// Precache all assets generated by webpack
// The `self.__WB_MANIFEST` is injected by WorkboxWebpackPlugin
precacheAndRoute(self.__WB_MANIFEST)

// Cache the Google Fonts stylesheets with a Cache First strategy
registerRoute(
  ({ url }) => url.origin === "https://fonts.googleapis.com",
  new CacheFirst({
    cacheName: "google-fonts-stylesheets",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        maxEntries: 10,
      }),
    ],
  }),
)

// Cache the Google Fonts webfont files with a Cache First strategy
registerRoute(
  ({ url }) => url.origin === "https://fonts.gstatic.com",
  new CacheFirst({
    cacheName: "google-fonts-webfonts",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        maxEntries: 30,
      }),
    ],
  }),
)

// Cache Font Awesome CSS and fonts
registerRoute(
  ({ url }) => url.origin === "https://cdnjs.cloudflare.com" && url.pathname.includes("font-awesome"),
  new CacheFirst({
    cacheName: "font-awesome-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
        maxEntries: 5,
      }),
    ],
  }),
)

// Cache Leaflet CSS and images
registerRoute(
  ({ url }) =>
    url.origin === "https://unpkg.com" && (url.pathname.includes("leaflet.css") || url.pathname.includes("images")),
  new CacheFirst({
    cacheName: "leaflet-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
        maxEntries: 10,
      }),
    ],
  }),
)

// Cache images with a Cache First strategy
registerRoute(
  ({ request }) => request.destination === "image",
  new CacheFirst({
    cacheName: "images-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 Days
      }),
    ],
  }),
)

// Cache API responses (stories) with a Stale While Revalidate strategy
registerRoute(
  ({ url }) => url.origin === "https://story-api.dicoding.dev",
  new NetworkFirst({
    cacheName: "api-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 Hours
      }),
    ],
  }),
)

// Handle push notifications
self.addEventListener("push", (event) => {
  const data = event.data ? event.data.json() : {}

  const title = data.title || "Dicoding Story App"
  const options = {
    body: data.body || "You have a new story!",
    icon: data.icon || "/images/icon/icon-192x192.png",
    badge: data.badge || "/images/icon/icon-96x96.png",
    image: data.image,
    data: {
      url: data.url || self.location.origin,
    },
  }

  event.waitUntil(self.registration.showNotification(title, options))
})

// Handle notification clicks
self.addEventListener("notificationclick", (event) => {
  event.notification.close()
  const urlToOpen = event.notification.data.url || self.location.origin

  event.waitUntil(
    clients
      .matchAll({
        type: "window",
        includeUncontrolled: true,
      })
      .then((clientList) => {
        for (const client of clientList) {
          if (client.url.includes(urlToOpen) && "focus" in client) {
            return client.focus()
          }
        }
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen)
        }
        return null
      }),
  )
})

// Handle install event to skip waiting
self.addEventListener("install", (event) => {
  self.skipWaiting()
})

// Handle activate event to claim clients
self.addEventListener("activate", (event) => {
  event.waitUntil(clients.claim())
})
